library(ggplot2)

#
# Prior to
# https://github.com/udacity/CarND-Capstone/commit/d9f276958933b8c5b9ac6702a8f5b67d458d59da
# the value for `steer_ratio` in dbw_sim.launch was incorrect. I ran some
# experiments to try to find the correct value, before Udacity fixed it.
#
# Data were generated by changing the dbw_node to publish a constant throttle
# and steering angle:
#
#     throttle, brake, steer = [0.2, 0, 0.75 * 2 * math.pi]
#     self.publish(throttle, brake, steer)
#
# for angles of 0.125, 0.25, 0.5, 0.75 and turns of the steering wheel. The
# position data from the simulator were captured from
# `rostopic echo /current_pose` and stored in circle_test_data.tar.xz. When
# uncompressed and untar'd, the circle_yml_to_csv.py script converts the YAML
# files in the tar.xz into CSV for processing here.
#

circles <- do.call(
  rbind,
  lapply(Sys.glob('circle_*.csv'), read.csv))

#
# Raw plot:
#

ggplot(circles, aes(x = x, y = y)) +
  geom_point(aes(color = factor(steer_angle))) +
  coord_fixed()

#
# There are some 'tails' at the start and end. Let's get rid of some points at
# the start and the end. We really just need one complete circle.
#

trimCircles <- function (circles) {
  trimCircle <- function (circle) {
    circle[100:(nrow(circle)-400),]
  }
  do.call(
    rbind,
    by(circles, circles$steer_angle, trimCircle))
}
trimmedCircles <- trimCircles(circles)
ggplot(trimmedCircles, aes(x = x, y = y)) +
  geom_point(aes(color = factor(steer_angle)), alpha = 0.1) +
  coord_fixed()

#
# Get bounding boxes for each circle to find radii.
#

findRadii <- function (circles) {
  findRadius <- function (circle) {
    xMin <- min(circle$x)
    yMin <- min(circle$y)
    xMax <- max(circle$x)
    yMax <- max(circle$y)
    xRadius = (xMax - xMin) / 2
    yRadius = (yMax - yMin) / 2
    data.frame(
      steer_angle = circle$steer_angle[1],
      radius = (xRadius + yRadius) / 2
    )
  }
  do.call(
    rbind,
    by(circles, circles$steer_angle, findRadius))
}
circleRadii <- findRadii(trimmedCircles)
circleRadii

#
# Now let's see what parameters we need for a bicycle model to get the same
# radii by guess-and-check.
#

#
# (x, y): initial position
# yaw: initial yaw, in radians
# v: initial speed, in m/s
# delta: steering angle, in radians
# a: acceleration, in m/s^2
# [t, t1): time range in steps of dt, in seconds
# lf: wheel base length (front to rear axles), in meters
#

simulateBicycle <- function(x, y, yaw, v, delta, a, t, dt, t1, lf) {
  n <- floor((t1 - t) / dt)
  x <- rep(x, times = n)
  y <- rep(y, times = n)
  yaw <- rep(yaw, times = n)
  v <- rep(v, times = n)
  for (i in 2:n) {
    x[i] <- x[i - 1] + v[i - 1] * cos(yaw[i - 1]) * dt
    y[i] <- y[i - 1] + v[i - 1] * sin(yaw[i - 1]) * dt
    yaw[i] <- yaw[i - 1] + v[i - 1] / lf * delta * dt
    v[i] <- v[i - 1] + a * dt
  }
  data.frame(x, y, yaw, v)
}

simulateBicycles <- function(steerAngles, wheelBase) {
  runSimulation <- function(steerAngle) {
    transform(
      simulateBicycle(0, 0, 0, 10, steerAngle, 0, 0, 1/50, 100, wheelBase),
      steer_angle = steerAngle)
  }
  do.call(rbind, lapply(steerAngles, runSimulation))
}
bicycleCircles <- simulateBicycles(
  c(0.125, 0.25, 0.50, 0.75) * 2 * pi / 17.5, 3)
bicycleCircleRadii <- findRadii(bicycleCircles)
bicycleCircleRadii

ggplot(bicycleCircles, aes(x = x, y = y)) +
  geom_point(alpha = 0.1) +
  coord_fixed()

#
# So, it looks like the steering ratio is closer to 17.5, if the wheelbase is 3.
#

